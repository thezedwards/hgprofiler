import time
import json
from datetime import datetime
from flask import g, request, Response
from flask.ext.classy import FlaskView
from werkzeug.exceptions import BadRequest, NotAcceptable

from app.authorization import login_required
import app.config
import app.database


class NotificationView(FlaskView):
    """
    Send notifications using Server-Sent Events (SSE).

    Based on this:
    http://stackoverflow.com/questions/13386681/streaming-data-with-python-and-flask
    """

    CHANNELS = (
        'archive',
        'category',
        'result',
        'site',
        'worker',
        'proxy',
        'user',
    )

    __should_quit = False

    @classmethod
    def quit_notifications(cls):
        """A helper function to end long-running notification threads. """
        cls.__should_quit = True

    @login_required
    def index(self):
        """ Open an SSE stream. """

        if request.headers.get('Accept') == 'text/event-stream':
            redis = app.database.get_redis(dict(g.config.items('redis')))
            pubsub = redis.pubsub(ignore_subscribe_messages=True)
            pubsub.subscribe(*self.__class__.CHANNELS)
            client_id = request.args.get('client-id', '')

            if client_id.strip() == '':
                raise BadRequest('`client-id` query parameter is required.')

            return Response(self._stream(pubsub, client_id, g.user.id),
                            content_type='text/event-stream')

        else:
            message = 'This endpoint is only for use with server-sent ' \
                      'events (SSE).'
            raise NotAcceptable(message)

    def _stream(self, pubsub, client_id, user_id):
        """
        Stream events.

        If an event has a source_client_id key set, then it is *not*
        sent to that client.
        """

        # Prime the stream. (This forces headers to be sent. Otherwise the
        # client will think the stream is not open yet.)
        yield ''

        # Track dummy events sent to keep connection alive.
        event_time = datetime.now()

        # Now send real events from the Redis pubsub channel.
        while True:
            if self.__class__.__should_quit:
                break

            message = pubsub.get_message()

            # Send dummy data to keep connection alive
            time_since_event = datetime.now() - event_time

            if time_since_event.seconds > 60:
                yield _get_ping_event()

                event_time = datetime.now()

            # Send any new messages
            if message is not None:
                channel = message['channel'].decode('utf8')
                data = _get_message_data(message, client_id, user_id)

                if data is not None:
                    data_str = json.dumps(data)
                    event_time = datetime.now()
                    yield 'event: {}\ndata: {}\n\n'.format(channel, data_str)
                else:
                    time.sleep(0.2)
            else:
                time.sleep(0.2)


def _get_message_data(message, client_id, user_id):
    """
    Return message data for this user.
    """
    data = json.loads(message['data'].decode('utf8'))
    source_client_id = data.pop('source_client_id', '')

    # Don't publish messages for events generated by this user.
    if source_client_id == client_id:
        return None

    # Only publish data for this user.
    if 'user_id' in data:
        if data['user_id'] != user_id:
            return None

    return data


def _get_ping_event():
    """
    Return ping event string.
    """
    data = {
        'timestamp': datetime.now().isoformat()
    }
    data_str = json.dumps(data)
    channel = 'ping'

    return 'event: {}\ndata: {}\n\n'.format(channel, data_str)
